# Shared Memory Consistency Models: A Tutorial

### Abstract
`memory consistency model`

`sequential consistency`

`relaxed Consistency models`

### Definition
`memory consistency model`


`sequential consistency`
[A multiprocessor system is **sequentially consistent** if] the result of any execution is
the same as if the operations of all the processors were executed in some sequential order, and the
operations of each individual processor appear in this sequence in the order specified by its program

`cache coherence protocal`
It's used for propagating a newly written value to all cached
copies of the modified location There are many definitions about this pahrase, one is special.
(1) a write is eventually made visible to all processors, and (2) writes to the same location appear to be seen in the same order by all processors (also referred to as serialization of writes to the same location)


`relaxed Consistency models`

`read-modify-write`

`overlapped write`
overlapped operation can return immediately, even though the operation has not been completed
[ref](https://docs.microsoft.com/en-us/windows/desktop/sync/synchronization-and-overlapped-input-and-output)

`non-blocking read operation`
same as **overlapped read**


|hardware optimization|with cache|how to solve|have trouble in uniprocesser|Remark|
|:-                  :|:-:       |:-         :|:-                         :|:-:   |
|writer buffers with by-passing | No|      | No | overlapped WR, a write following read|
|overlapped write operation     | No|      | No | overlapped WW, two writes|
|non-blocking read operation    | No|      | No | overlapped RR or RW, from a read to a following read or write, RW is not commonly used in then(maybe now 2018)|


### Keynote
----
Q: Why there are only five types, how they are divide ?
A:
relaxed memory consistency models based on two key characteristics: (1) how they relax the program order requirement, and (2) how they relax the write atomicity requirement
```
Relex
    ---program order
    |   |______________write to read
    |   |______________write to write
    |   |______________read to (read or write)
    |
    |--write atomicity
        |______________read other's write early
        |______________read own write early

```
read early means a read to return the value of other/own processor’s write before all cached copies of the accessed location receive the
invalidation or update messages generated by the write.



----
Q: There are two aspects to sequential consistency:
(1) maintaining program order among operations from individual processors, and
(2) maintaining a single sequential order among operations from all processors.
So how to understant this two aspects ?

A: (1)----\>importance of program order among operations from a single processor
(2)----\>the importance of atomic execution of memory operations

----
Q:What's the difference between `sequential consistency` and `cache coherence` ?
the former requires writes to **all** locations (not just the same location) to be seen in the same order by all processors, and also explicitly requires that operations of a single processor appear to execute in program order.

A:`cache coherence` propagates the new value, `sequential consistency` places an early and late bound on when a new value can be propagated tp any given processor.

-----
Q:What's the difference between
`writes to the same location appear to be seen in the same order by all processors` and
`writes to the all locations appear to be seen in the same order by all processors` ?

A:overlapped write to different location, for example,
```
// code 1
init x = 0, y = 0, D = 100

P1              P2
    x = 1       if(y == 0){}
    y = 1       D = x

D can be 0
```

overlapped write to same location, for example,
```
// code 2
init x = 0, D = 100

P1              P2
    x = 1       if(x == 0){}
    x = 2       D = x

D can be 1;
If P1 and P2 are connected with interconection,
it's possiable that x = 2 reached the P2 before x = 1 did.
```

----
Q: Why cache make things more tricky ?
A: Apart from cache coherence protocal, detecting the completion of write operation and atomicity of write are challenges.
In a system without caches, the acknowledgement response may be generated as soon as the write reaches its target memory module. However, with caches, acknowlegement shoulde be signal from every processor whose retain the value in their cache.

As for atomicity, the following code emphasize it's importance.
```
// code 3
Initially A = B = C = 0
P1      P2      P3                  P4
A = 1   A = 2   while (B != 1)      while (B != 1)
B = 1   C = 1   while (C != 1)      while (C != 1)
register1 = A register2 = A
```
It seems that we have already mentioned the importance of atomicity, now the response shoulde come from all the cache instead of just the memory modules

----
Q: how to understand the constrains for the relaxation mode ? what's is the meaning of `data and control dependency` ? any diffierence between uniprocessor and multiprocessor version of it?
> implicitly assume that the following constraints are satisfied.
> 1. all models require a write to eventually be made visible to all processors and for writes to the same location to be serialized.
> 2. all models enforce uniprocessor data and control dependences.
> 3. models that relax the program order from reads to following write operations must also maintain a subtle form of multiprocessor data and control dependences
> this latter constraint is inherently upheld by all processor designs we are aware of and can also
> be easily maintained by the compiler.

W:
[Dependence analysis](https://en.wikipedia.org/wiki/Dependence_analysis)
[Data dependency](https://en.wikipedia.org/wiki/Data_dependency)
<!-- TODO: read the links -->


| Myth                                                                                                                                                                                                                                                                              | Reality                                                                                                                                                                       |
| -                                                                                                                                                                                                                                                                                 | -                                                                                                                                                                             |
| A memory consistency model only applies to systems that allow multiple copies of shared data; e.g., through caching.                                                                                                                                                              | write buffers, overlapping write, non-blocling read                                                                                                                           |
| Most current systems are sequentially consistent                                                                                                                                                                                                                                  | No, for the sake of effiency, relaxed model are used                                                                                                                          |
| The memory consistency model only affects the design of the hardware                                                                                                                                                                                                              | No, e.g. optimizations allowed in the compiler.                                                                                                                               |
| The relationship of cache coherence protocols to memory consistency models: (i) a cache coherence protocol inherently supports sequential consistency, (ii) the memory consistency model depends on whether the system supports an invalidate or update based coherence protocol. | No, cache coherence protocol is only a part of the memory consistency model. No, given memory consistency model can allow both an invalidate or an update coherence protocol. |
| The memory model for a system may be defined solely by specifying the behavior of the processor (or the memory system).                                                                                                                                                           | memory consistency model is affected by the behavior of both the processor and the memory system.                                                                             |
| Relaxed memory consistency models may not be used to hide read latency.                                                                                                                                                                                                           | No, they can                                                                                                                                                                  |
| Relaxed consistency models require the use of extra synchronization.                                                                                                                                                                                                              |
Most of the relaxed models discussed in this article do not require extra synchronization in the program. In particular, the programmercentric framework only requires that operations be distinguished
or labeled correctly. Other models provide safety nets that allow
the programmer to enforce the required constraints for achieving
correctness.
Relaxed memory consistency models do
not allow chaotic (or asynchronous)
algorithms.
The models discussed in this article allow chaotic (or asynchronous)
algorithms. With system-centric models, the programmer can reason about the correctness of such algorithms by considering the optimizations that are enabled by the model. The programmer-centric
approach simply requires the programmer to explicitly identify the
operations that are involved in a race. For many chaotic algorithms,
the former approach may provide higher performance since such
algorithms do not depend on sequential consistency for correctness


1. Relaxing the `write` to `read` program order

```
// code 4
Initially A = Flag1 = Flag2 = 0             
P1                   P2                     
Flag1 = 1            Flag2 = 1              
A = 1                A = 2                  
register1 = A        register3 = A          
register2 = Flag2    register4 = Flag1      
                                            
Result: register1 = 1, register3 = 2,       
register2 = register4 = 0

// code 5
Initially A = B = 0
P1          P2              P3
A = 1
            if(A==1)
                B = 1
                            if(B == 1)
                                register1 = A
Result: B = 1, register1 = 0
```

| model                                    | specification                                                                                                                                          | code 4 | code 5 |
| -                                        | -                                                                                                                                                      |
| IBM 370                                  | prohibits a read from returning the value of a write before the write is made visible to all processors                                                | F      | F      |
| SPARC V8 total store ordering model(TSO) | allowing a read to return the value of its own processor’s write even before the write is serialized with respect to other writes to the same location | T      | F      |
| processor model(PC)                      | a read can return the value of any write before the write is serialized or made visible to other processors                                            | T      | T      |


### Questions
1. overlapped, non-blocking, by-passing has any difference in the context of IO ?
2. how to prove sequential consistency can guarantee the correctness of program ?
correctness of program means that obey the program order
3. IBM 370 model did a relaxation ?





### Inspired
1. relaxed model makes compiler have more effiency optimazation ?
2. data or synchronization

### Ref
1. [Dekker's algorithm](https://en.wikipedia.org/wiki/Dekker%27s_algorithm)

### Todo
1. memory semantics in uniprocessor tells what ?
2.


### pactice
std memory order in google, we found something amazing !
