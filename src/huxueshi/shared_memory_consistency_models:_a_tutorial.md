# Shared Memory Consistency Models: A Tutorial

### Abstract
```
`memory consistency model`: writing correct and efficient program needed
        ||
        ||(most intuitive model)
        ||
        \/
`sequential consistency`: restrict optimization
        ||      ||
        ||      ||(part)
        ||      ||
        ||      ||
        ||      \/
        ||  `cache coherence protocal`
        ||
        ||(alleviate problem)
        ||
        \/
`relaxed Consistency models`
```

### Definition
`memory consistency model`
[consistency model](https://en.wikipedia.org/wiki/Consistency_model)
the data consistency model specifies a **contract** between programmer and system, wherein the system guarantees that if the programmer follows the rules, memory will be consistent and the results of reading, writing, or updating memory will be predictable.


`sequential consistency`
[A multiprocessor system is **sequentially consistent** if] the result of any execution is
the same as if the operations of all the processors were executed in some sequential order, and the
operations of each individual processor appear in this sequence in the order specified by its program

`cache coherence protocol`
It's used for propagating a newly written value to all cached
copies of the modified location There are many definitions about this phrase, one is special.
(1) a write is eventually made visible to all processors, and (2) writes to the same location appear to be seen in the same order by all processors (also referred to as serialization of writes to the same location)


`read-modify-write`
[wiki](https://en.wikipedia.org/wiki/Read-modify-write)

`safety net`
[SafetyNet: Improving the Availability of Shared Memory Multiprocessors with Global Checkpoint/Recovery](https://www.cis.upenn.edu/~milom/papers/isca02_safetynet.pdf)
safety net is not a specific technology, it is byproduct of relaxation including *serialization instruction* *read-modify-write* *stall bar* and so on

`overlapped write`
overlapped operation can return immediately, even though the operation has not been completed
[ref](https://docs.microsoft.com/en-us/windows/desktop/sync/synchronization-and-overlapped-input-and-output)

`non-blocking read operation`
same as **overlapped read**

`release consistency`

`weak order`

| hardware optimizatio           | with cache | how to solve | have trouble in uniprocessor | Remark                                                                                                         |
| :-:                            | :-:        | :-:          | :-:                          | :-:                                                                                                            |
| writer buffers with by-passing | No         |              | No                           | overlapped WR, a write following read                                                                          |
| overlapped write operation     | No         |              | No                           | overlapped WW, two writes                                                                                      |
| non-blocking read operation    | No         |              | No                           | overlapped RR or RW, from a read to a following read or write, RW is not commonly used in then(maybe now 2018) |

### Keynote
----
Q: Why there are only five types, how they are divide ?
A:
relaxed memory consistency models based on two key characteristics: (1) how they relax the program order requirement, and (2) how they relax the write atomicity requirement
```
Relax
    ---program order
    |   |______________write to read
    |   |______________write to write
    |   |______________read to (read or write)
    |
    |--write atomicity
        |______________read other's write early
        |______________read own write early

```
read early means a read to return the value of other/own processorâ€™s write before all cached copies of the accessed location receive the
invalidation or update messages generated by the write.



----
Q: There are two aspects to sequential consistency:
(1) maintaining program order among operations from individual processors, and
(2) maintaining a single sequential order among operations from all processors.
So how to understand this two aspects ?

A: (1)----\>importance of program order among operations from a single processor
(2)----\>the importance of atomic execution of memory operations

----
Q:What's the difference between `sequential consistency` and `cache coherence` ?
the former requires writes to **all** locations (not just the same location) to be seen in the same order by all processors, and also explicitly requires that operations of a single processor appear to execute in program order.

A:`cache coherence` propagates the new value, `sequential consistency` places an early and late bound on when a new value can be propagated to any given processor.

-----
Q:What's the difference between
`writes to the same location appear to be seen in the same order by all processors` and
`writes to the all locations appear to be seen in the same order by all processors` ?

A:overlapped write to different location, for example,
```
// code 1
init x = 0, y = 0, D = 100

P1              P2
    x = 1       if(y == 0){}
    y = 1       D = x

D can be 0
```

Overlapped write to same location, for example,
```
// code 2
init x = 0, D = 100

P1              P2
    x = 1       if(x == 0){}
    x = 2       D = x

D can be 1;
If P1 and P2 are connected with interconnection,
it's possible that x = 2 reached the P2 before x = 1 did.
```

----
Q: Why cache make things more tricky ?
A: Apart from cache coherence protocol, detecting the completion of write operation and atomicity of write are challenges.
In a system without caches, the acknowledgement response may be generated as soon as the write reaches its target memory module. However, with caches, acknowledgement should be signal from every processor whose retain the value in their cache.

As for atomicity, the following code emphasize it's importance.
```
// code 3
Initially A = B = C = 0
P1      P2      P3                  P4
A = 1   A = 2   while (B != 1)      while (B != 1)
B = 1   C = 1   while (C != 1)      while (C != 1)
register1 = A register2 = A
```
It seems that we have already mentioned the importance of atomicity, now the response should come from all the cache instead of just the memory modules

----
Q: how to understand the constrains for the relaxation mode ? what's is the meaning of `data and control dependency` ? any difference between uniprocessor and multiprocessor version of it?
> implicitly assume that the following constraints are satisfied.
> 1. all models require a write to eventually be made visible to all processors and for writes to the same location to be serialized.
> 2. all models enforce uniprocessor data and control dependences.
> 3. models that relax the program order from reads to following write operations must also maintain a subtle form of multiprocessor data and control dependences
> this latter constraint is inherently upheld by all processor designs we are aware of and can also
> be easily maintained by the compiler.

W:
[Dependence analysis](https://en.wikipedia.org/wiki/Dependence_analysis)
[Data dependency](https://en.wikipedia.org/wiki/Data_dependency)
<!-- TODO: read the links -->


----
Q: why relaxation is accumulative ? In another words, why there is no such model which only allow `write` to `write` relaxation ?
W: I don't know yet.

----
Q: how `read-modify-write` worked as safety net ?
W: Haven't read that, interrupted by the arch.


| Myth                                                                                                                                                                                                                                                                              | Reality                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| -                                                                                                                                                                                                                                                                                 | -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| A memory consistency model only applies to systems that allow multiple copies of shared data; e.g., through caching.                                                                                                                                                              | write buffers, overlapping write, non-blocking read                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| Most current systems are sequentially consistent                                                                                                                                                                                                                                  | No, for the sake of efficiency, relaxed model are used                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| The memory consistency model only affects the design of the hardware                                                                                                                                                                                                              | No, e.g. optimizations allowed in the compiler.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| The relationship of cache coherence protocols to memory consistency models: (i) a cache coherence protocol inherently supports sequential consistency, (ii) the memory consistency model depends on whether the system supports an invalidate or update based coherence protocol. | No, cache coherence protocol is only a part of the memory consistency model. No, given memory consistency model can allow both an invalidate or an update coherence protocol.                                                                                                                                                                                                                                                                                                                                                                   |
| The memory model for a system may be defined solely by specifying the behavior of the processor (or the memory system).                                                                                                                                                           | memory consistency model is affected by the behavior of both the processor and the memory system.                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Relaxed memory consistency models may not be used to hide read latency.                                                                                                                                                                                                           | No, they can                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Relaxed consistency models require the use of extra synchronization.                                                                                                                                                                                                              | Most of the relaxed models discussed in this article do not require extra synchronization in the program. In particular, the programmer centric framework only requires that operations be distinguished or labeled correctly. Other models provide safety nets that allow the programmer to enforce the required constraints for achieving correctness.                                                                                                                                                                                        |
| Relaxed memory consistency models do not allow chaotic (or asynchronous) algorithms.                                                                                                                                                                                              | The models discussed in this article allow chaotic (or asynchronous) algorithms. With system-centric models, the programmer can reason about the correctness of such algorithms by considering the optimizations that are enabled by the model. The programmer-centric approach simply requires the programmer to explicitly identify the operations that are involved in a race. For many chaotic algorithms, the former approach may provide higher performance since such algorithms do not depend on sequential consistency for correctness |

##### Relaxing the `write` to `read` program order

```
// code 4
Initially A = Flag1 = Flag2 = 0             
P1                   P2                     
Flag1 = 1            Flag2 = 1              
A = 1                A = 2                  
register1 = A        register3 = A          
register2 = Flag2    register4 = Flag1      

Result: register1 = 1, register3 = 2,       
register2 = register4 = 0

// code 5
Initially A = B = 0
P1          P2              P3
A = 1
            if(A==1)
                B = 1
                            if(B == 1)
                                register1 = A
Result: B = 1, register1 = 0
```
| model                                    | specification                                                                                                                                          | code 4 | code 5 | safety net |
| -                                        | -                                                                                                                                                      | -      | -      | -          |
| IBM 370                                  | prohibits a read from returning the value of a write before the write is made visible to all processors                                                | F      | F      |serialization instruction|
| SPARC V8 total store ordering model(`TSO`) | allowing a read to return the value of its own processorâ€™s write even before the write is serialized with respect to other writes to the same location | T      | F      |programmer can use |
| processor model(`PC`)                      | a read can return the value of any write before the write is serialized or made visible to other processors                                            | T      | T      ||

##### Relaxing `write` to `read` and `write` to `write` program orders ?

| model                                    | specification|safety net|
| -                                        | -            |-|
|SPARC V8 partial store ordering model(`PSO`)|`STBAR` instruction|

##### Relaxing all



### Questions
1. overlapped, non-blocking, by-passing has any difference in the context of IO ?
2. how to prove sequential consistency can guarantee the correctness of program ?
Correctness of program means that obey the program order
3. IBM 370 model did a relaxation ?
4. What's chaotic(or asynchronous) algorithm ?



### Inspired
1. relaxed model makes compiler have more efficiency optimization ?
2. data or synchronization

### Ref
1. [Dekker's algorithm](https://en.wikipedia.org/wiki/Dekker%27s_algorithm)

### Todo
1. memory semantics in uniprocessor tells what ?


### Pactice
std memory order in google, we found something amazing !


#### `Operations on atomic types`
load&store
compare&exchange


##### `std::memory_order`
| Value                   | Explanation                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| -                       | -                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| memory\_order\_relaxed  | Relaxed operation: there are no synchronization or ordering constraints imposed on other reads or writes, only this operation's atomicity is guaranteed (see Relaxed ordering below)                                                                                                                                                                                                                                                                         |
| memory\_order\_consume  | A load operation with this memory order performs a consume operation on the affected memory location: no reads or writes in the current thread dependent on the value currently loaded can be reordered before this load. Writes to data-dependent variables in other threads that release the same atomic variable are visible in the current thread. On most platforms, this affects compiler optimizations only (see Release-Consume ordering below)      |
| memory\_order\_acquire  | A load operation with this memory order performs the acquire operation on the affected memory location: no reads or writes in the current thread can be reordered before this load. All writes in other threads that release the same atomic variable are visible in the current thread (see Release-Acquire ordering below)                                                                                                                                 |
| memory\_order\_release  | A store operation with this memory order performs the release operation: no reads or writes in the current thread can be reordered after this store. All writes in the current thread are visible in other threads that acquire the same atomic variable (see Release-Acquire ordering below) and writes that carry a dependency into the atomic variable become visible in other threads that consume the same atomic (see Release-Consume ordering below). |
| memory\_order\_acq\_rel | A read-modify-write operation with this memory order is both an acquire operation and a release operation. No memory reads or writes in the current thread can be reordered before or after this store. All writes in other threads that release the same atomic variable are visible before the modification and the modification is visible in other threads that acquire the same atomic variable.                                                        |
| memory\_order\_seq\_cst | A load operation with this memory order performs an acquire operation, a store performs a release operation, and read-modify-write performs both an acquire operation and a release operation, plus a single total order exists in which all threads observe all modifications in the same order (see Sequentially-consistent ordering below)                                                                                                                |

##### `std::atomic_thread_fence`
Fence-atomic synchronization
Atomic-fence synchronization
Fence-fence synchronization
